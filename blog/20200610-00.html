<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>排序汇总 | 我的博客</title>
    <link rel="stylesheet" href="css/style.css">
</head>
<body>
    <div class="nav">
        <a href="index.html" class="nav-home">返回主页</a>
    </div>
    <div class="container post-page">
        <main>
            <article class="post">
                <h1>排序汇总</h1>
                <div class="post-meta">
                    2020-06-10 · 
                    算法
                </div>
                <div class="post-content">
                    <hr/>
<h3>BubbleSort</h3>
<p>用循环使数组元素按顺序两两比较<br/>
通过数值互换将比较大的逐渐向下沉<br/>
如果共有<code>n</code>个数，那么将进行<code>n-1</code>趟比较；<br/>
而第j趟比较将进行<code>n-j</code>次两两比较；<br/>
<strong>时间复杂度：</strong><code>O(n*n)</code><br/>
<strong>空间复杂度：</strong><code>O(1)</code></p>
<div class="codehilite"><div class_="code-lang">C++</div><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">BubbleSort</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">ary</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w">    </span><span class="c1">//共进行size-1趟比较</span>
<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">)</span><span class="w">    </span><span class="c1">//第i趟进行size-i次比较</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">ary</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">ary</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
<span class="w">                </span><span class="n">swap</span><span class="p">(</span><span class="n">ary</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="w"> </span><span class="n">ary</span><span class="p">[</span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div>
<hr/>
<h3>SelectionSort</h3>
<p>先将n个数中最小的数与a[0]对换；<br/>
再将a[1]~a[n-1]中最小的数与a[1]交换...<br/>
每比较一轮，找出未比较的数中最小的一个，共比较n-1轮；<br/>
<strong>时间复杂度：</strong><code>O(n*n)</code> <br/>
<strong>空间复杂度：</strong><code>O(1)</code></p>
<div class="codehilite"><div class_="code-lang">C++</div><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">SelectionSort</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">ary</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w">        </span><span class="c1">//共进行size-1趟比较</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w">        </span><span class="c1">//记录当前下标</span>
<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w">        </span><span class="c1">//从当前元素的下个元素开始比较，1~size</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">ary</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">ary</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
<span class="w">                </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">j</span><span class="p">;</span><span class="w">        </span><span class="c1">//记录比当前元素小的元素的下标</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w">        </span><span class="c1">//交换下标了才交换值，否则不交换</span>
<span class="w">            </span><span class="n">swap</span><span class="p">(</span><span class="n">ary</span><span class="p">[</span><span class="n">k</span><span class="p">],</span><span class="w"> </span><span class="n">ary</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">                    </span><span class="c1">//把k中存储的最小的数的下标，和a[i]对换</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div>
<hr/>
<h3>InsertionSort</h3>
<p>为元素找到插入点，然后该点后面的元素依次后移，最后插入元素；<br/>
对于几乎排好序的数列，插入排序表现很好<br/>
可以用二分查找来优化寻找插入点的过程<br/>
<strong>时间复杂度：</strong>普通插入<code>O(n*n)</code>，二分插入<code>O(nlgn)</code> <br/>
<strong>空间复杂度：</strong><code>O(1)</code></p>
<h4>普通插入</h4>
<div class="codehilite"><div class_="code-lang">C++</div><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">InsertionSort</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">ary</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w">        </span><span class="c1">//从第二个元素开始，到最后一个元素</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ary</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="k">while</span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">ary</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">t</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">ary</span><span class="p">[</span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ary</span><span class="p">[</span><span class="n">j</span><span class="p">];</span><span class="w">    </span><span class="c1">//逐个后移</span>
<span class="w">            </span><span class="o">--</span><span class="n">j</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">ary</span><span class="p">[</span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="p">;</span><span class="w">    </span><span class="c1">//插入到移出的缝隙中</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div>
<h4>二分插入</h4>
<div class="codehilite"><div class_="code-lang">C++</div><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">InsertionSort</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">ary</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w">        </span><span class="c1">//第二个元素到最后一个元素</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ary</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">low</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">mid</span><span class="p">,</span><span class="w"> </span><span class="n">high</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">    </span><span class="c1">//注意high=i-1，这样就能保证low-high区间内是有序的</span>
<span class="w">        </span><span class="k">while</span><span class="p">(</span><span class="n">low</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">high</span><span class="p">)</span><span class="w">    </span><span class="c1">//low才是ary[i]插入的正确位置</span>
<span class="w">        </span><span class="p">{</span><span class="w">        </span><span class="c1">//循环的结果就是low=t下标-1，mid=t下标+1</span>
<span class="w">            </span><span class="n">mid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">high</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">low</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">t</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">ary</span><span class="p">[</span><span class="n">mid</span><span class="p">])</span>
<span class="w">                </span><span class="n">high</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mid</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">t</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">ary</span><span class="p">[</span><span class="n">mid</span><span class="p">])</span>
<span class="w">                </span><span class="n">low</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">    </span><span class="c1">//j==high</span>
<span class="w">        </span><span class="k">while</span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">low</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">ary</span><span class="p">[</span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ary</span><span class="p">[</span><span class="n">j</span><span class="p">];</span><span class="w">    </span><span class="c1">//逐个后移</span>
<span class="w">            </span><span class="o">--</span><span class="n">j</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">ary</span><span class="p">[</span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="p">;</span><span class="w">    </span><span class="c1">//插入到移出的缝隙中</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div>
<hr/>
<h3>MergeSort</h3>
<p>归并排序采用分治法，将元素递归分成若干组，排好序后再逐级合并（Merge过程最坏情况下的比较次数为2n-1）<br/>
归并排序最好、最坏、平均复杂度都一样，比较占用空间，但却是稳定高效的排序算法，仅次于QuickSort<br/>
<strong>时间复杂度：</strong><code>O(nlgn)</code><br/>
<strong>空间复杂度：</strong><code>O(n)</code><br/>
<strong>stable：</strong><code>否</code></p>
<div class="codehilite"><div class_="code-lang">C++</div><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">Merge</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">ary</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">low</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">mid</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">high</span><span class="p">)</span><span class="c1">//前提是两个区间都是排好序的，low&lt;=mid&lt;high</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">n1</span><span class="w"> </span><span class="o">=</span><span class="n">mid</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">low</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">    </span><span class="c1">//左区间元素个数</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">n2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">high</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">mid</span><span class="p">;</span><span class="w">    </span><span class="c1">//右区间元素个数</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">[</span><span class="n">n1</span><span class="p">];</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">[</span><span class="n">n2</span><span class="p">];</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n1</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">        </span><span class="n">left</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ary</span><span class="p">[</span><span class="n">low</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">];</span><span class="w">    </span><span class="c1">//将左区间的元素复制到left</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n2</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">)</span>
<span class="w">        </span><span class="n">right</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ary</span><span class="p">[</span><span class="n">mid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span><span class="w">    </span><span class="c1">//将右区间的元素复制到right</span>
<span class="w">    </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">low</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n2</span><span class="p">)</span><span class="w">    </span><span class="c1">//将left、right元素两两比较，小的放入原数组，大的不动</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">left</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">right</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
<span class="w">            </span><span class="n">ary</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">left</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">            </span><span class="n">ary</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">right</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n1</span><span class="p">)</span><span class="w">        </span><span class="c1">//如果有剩余的，则全部合并到原数组后面</span>
<span class="w">        </span><span class="n">ary</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">left</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n2</span><span class="p">)</span><span class="w">        </span><span class="c1">//剩余的，肯定都是比前面大的</span>
<span class="w">        </span><span class="n">ary</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">right</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>
<span class="w">    </span><span class="k">delete</span><span class="w"> </span><span class="p">[]</span><span class="n">left</span><span class="p">;</span>
<span class="w">    </span><span class="k">delete</span><span class="w"> </span><span class="p">[]</span><span class="n">right</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">MergeSort</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">ary</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">low</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">high</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">low</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">high</span><span class="p">)</span><span class="w">    </span><span class="c1">//只有一个元素时，认为是有序的，递归出口</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">mid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">low</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">high</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">    </span><span class="c1">//将当前区间拆分成两半</span>
<span class="w">        </span><span class="n">MergeSort</span><span class="p">(</span><span class="n">ary</span><span class="p">,</span><span class="w"> </span><span class="n">low</span><span class="p">,</span><span class="w"> </span><span class="n">mid</span><span class="p">);</span><span class="w">    </span><span class="c1">//递归拆分左区间</span>
<span class="w">        </span><span class="n">MergeSort</span><span class="p">(</span><span class="n">ary</span><span class="p">,</span><span class="w"> </span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">high</span><span class="p">);</span><span class="w">    </span><span class="c1">//递归拆分右区间</span>
<span class="w">        </span><span class="n">Merge</span><span class="p">(</span><span class="n">ary</span><span class="p">,</span><span class="w"> </span><span class="n">low</span><span class="p">,</span><span class="w"> </span><span class="n">mid</span><span class="p">,</span><span class="w"> </span><span class="n">high</span><span class="p">);</span><span class="w">    </span><span class="c1">//将当前两个排好序的区间合并</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span><span class="w">    </span><span class="c1">//递归执行的顺序是，先递归将左区间拆分成只包含1个元素的小区间，再递归将右区间拆分成只包含1个元素的小区间，最后逐级合并</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">7</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">};</span>
<span class="w">    </span><span class="n">MergeSort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">        </span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="err">\'</span><span class="w"> </span><span class="err">\'</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div>
<hr/>
<h3>HeapSort</h3>
<p>通过数据结构堆，来将插入排序和归并排序的优点结合起来，是一种渐进最优的排序<br/>
<strong>时间复杂度：</strong><code>O(nlgn)</code><br/>
<strong>空间复杂度：</strong><code>O(1)</code><br/>
<strong>stable：</strong><code>否</code></p>
<ol>
<li>（二叉）堆数据结构是一种数组对象，可以被视为一颗完全二叉树</li>
<li>对于从0开始的数组，给定一个结点下标i，其父结点的下标为(i-1)/2，左子树的下标为i<em>2+1，右子树的下标为i</em>2+2</li>
<li>可以通过左移/右移1位再+1/-1的方法来快速计算出父/子结点</li>
<li>二叉堆有两种：<ul>
<li>最大堆：某个结点的值至多和其父结点的值一样大；这样，堆中的最大元素就存储在根结点中</li>
<li>最小堆：和最大堆正相反<br/>
在堆排序算法中使用最大堆，在优先级队列中使用最小堆</li>
</ul>
</li>
<li>堆可以被视为一棵树：<ul>
<li>结点在树中的高度：从本结点到叶子的最长简单下降路径上结点的数目；因为具有n个元素的堆是基于一棵完全二叉树的，因此其高度为lgn</li>
<li>结点在树中的深度：从本结点到根结点的最长简单上升路径上结点的数目</li>
</ul>
</li>
<li>因为二叉堆的性质，数组的后二分之一元素都是叶子</li>
<li>在一个含有n个元素的二叉堆中，至多有n/(2的h次幂)个高度为h的结点（叶子高度为1）</li>
<li>完全二叉树：  <br/>
    所有叶子都在同一层且并不是满的，缺少右边的叶子（如果缺少的叶子的右边还有叶子，那么就不是完全二叉树）<br/>
        满二叉树：<br/>
    　国内定义：<br/>
    　　所有叶子都在同一层且刚好是满的<br/>
    　国外定义： <br/>
   　　所有结点，要么没有子结点（指叶子），要么有两个子结点<br/>
    满二叉树是完全二叉树的一个特例  </li>
<li>先级队列：<br/>
堆的一个很常见的应用：<br/>
作为高效的优先级队列；像堆一样，优先级队列也分为两种：最大优先级队列和最小优先级队列<br/>
    最大优先级队列的一个应用是分时计算机上进行作业调度；这种队列对要执行的各作业及它们之间的优先关系先加以记录，当上一个作业完成时，从所有等待的作业中，选择出具有最高优先级的作业执行<br/>
    最小优先级队列的一个应用是基于事件驱动的模拟器中，每一个都有时间做为其关键字；事件模拟要按时间的发生顺序进行，最小优先级队列比较合适</li>
<li>先级队列返回并去掉其根结点后，将数组最后一个元素交换到原根结点位置，而不是所有元素都移动</li>
</ol>
<div class="codehilite"><div class_="code-lang">C++</div><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">maxHeapify</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">ary</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">heapSize</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">    </span><span class="c1">//此函数是有前提的：以left和right为根的子树是最大堆</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">largest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">left</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">heapSize</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">ary</span><span class="p">[</span><span class="n">left</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">ary</span><span class="p">[</span><span class="n">largest</span><span class="p">])</span>
<span class="w">        </span><span class="n">largest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">left</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">right</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">heapSize</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">ary</span><span class="p">[</span><span class="n">right</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">ary</span><span class="p">[</span><span class="n">largest</span><span class="p">])</span>
<span class="w">        </span><span class="n">largest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">right</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">largest</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w">    </span><span class="c1">//largest是leftchild和rightchild中最大的</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">swap</span><span class="p">(</span><span class="n">ary</span><span class="p">[</span><span class="n">index</span><span class="p">],</span><span class="w"> </span><span class="n">ary</span><span class="p">[</span><span class="n">largest</span><span class="p">]);</span>
<span class="w">        </span><span class="n">maxHeapify</span><span class="p">(</span><span class="n">ary</span><span class="p">,</span><span class="w"> </span><span class="n">heapSize</span><span class="p">,</span><span class="w"> </span><span class="n">largest</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w">    </span><span class="c1">//将父结点交换到子结点后，继续检查该结点的子结点是否符合最大堆</span>
<span class="p">}</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">BuildmaxHeap</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">ary</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">heapSize</span><span class="p">)</span><span class="w">    </span><span class="c1">//构建最大堆</span>
<span class="p">{</span><span class="w">    </span><span class="c1">//因为后二分之一都是叶子没有子结点，所以从heapSize/2开始</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">heapSize</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="o">--</span><span class="n">i</span><span class="p">)</span>
<span class="w">        </span><span class="n">maxHeapify</span><span class="p">(</span><span class="n">ary</span><span class="p">,</span><span class="w"> </span><span class="n">heapSize</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span><span class="w">    </span><span class="c1">//从叶子到根结点</span>
<span class="p">}</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">HeapSort</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">ary</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">heapSize</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">BuildmaxHeap</span><span class="p">(</span><span class="n">ary</span><span class="p">,</span><span class="w"> </span><span class="n">heapSize</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">heapSize</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="o">--</span><span class="n">i</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">swap</span><span class="p">(</span><span class="n">ary</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">ary</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">        </span><span class="n">maxHeapify</span><span class="p">(</span><span class="n">ary</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">    </span><span class="c1">//堆大小逐渐减小，去掉最后面的排好序的元素</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">};</span>
<span class="w">    </span><span class="n">HeapSort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">        </span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="err">\'</span><span class="w"> </span><span class="err">\'</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div>
<hr/>
<h3>QuickSort</h3>
<p>快速排序是采用分治法的就地排序，最坏运行时间为O(n<em>n)，虽然最坏运行时间比较差，但快速排序仍然是排序的最佳实用选择，因为其平均性能相当好：期望时间复杂度为O(nlgn)，且O(nlgn)中的常数因子很小<br/>
快速排序的运行时间与划分是否对称有关，而后者又与选择了哪个元素来进行划分有关；如果划分是对称的，则与合并算法一样快；如果不对称就与插入排序一样慢<br/>
时间复杂度：平均O(nlgn)，最坏O(n</em>n)<br/>
空间复杂度：O(1)<br/>
stable：否<br/>
int Partition(int ary[], int left, int right)<br/>
{<br/>
    int i = left - 1;    //i的起始位置在left和j的前一位<br/>
    for(int j = left; j &lt; right; ++j)<br/>
        if(ary[j] &lt;= ary[right])    //主元设为当前区间最后一个元素,pivot=ary[right]<br/>
        {<br/>
            ++i;<br/>
            swap(ary[i], ary[j]);<br/>
        }<br/>
    swap(ary[i + 1], ary[right]);    //将主元从最后交换到i的下一位<br/>
                        //因为0~i都是小于主元的<br/>
                    //所以交换后主元的位置已经是排好序的位置<br/>
    return i + 1;    //返回当前主元的位置<br/>
}<br/>
void QuickSort(int ary[], int left, int right)<br/>
{<br/>
    if(left &lt; right)<br/>
    {<br/>
        int pivot = Partition(ary, left, right);<br/>
        QuickSort(ary, left, pivot - 1);    //因为主元位置已排好，所以跳过上次主元位置<br/>
        QuickSort(ary, pivot + 1, right);<br/>
    }<br/>
}<br/>
int main()<br/>
{<br/>
    int a[10] = {7, 8, 0, 9, 3, 6, 1, 2, 4, 5};<br/>
    QuickSort(a, 0, 9);    //数组名，最小下标，最大下标<br/>
    for(int i = 0; i &lt; 10; ++i)<br/>
        cout&lt;&lt;a[i]&lt;&lt;\' \';<br/>
    return 0;<br/>
}</p>
<hr/>
<p>void QuickSort(int ary[], int left, int right)    //尾递归<br/>
{<br/>
    while(left &lt; right)    //if改成while<br/>
    {<br/>
        int pivot = Partition(ary, left, right);<br/>
        QuickSort(ary, left, pivot - 1);    //先一直执行本句至底，回推只执行本句和下句<br/>
        left = pivot + 1;    //在回推过程中将left=pivot+1代入上句的left<br/>
    }<br/>
}</p>
<hr/>
<p>void QuickSort(int ary[], int left, int right)    //尾递归优化，栈深度为O(lgn)，时间复杂度不变<br/>
{<br/>
    while(left &lt; right)    //if改成while<br/>
    {<br/>
        int pivot = Partition(ary, left, right);<br/>
        if(pivot - left &lt; right - pivot)<br/>
        {<br/>
            QuickSort(ary, left, pivot - 1);<br/>
            left = pivot + 1;<br/>
        }<br/>
        else<br/>
        {<br/>
            QuickSort(ary, pivot + 1, right);<br/>
            right = pivot - 1;<br/>
        }<br/>
    }<br/>
}<br/>
==============================以上是比较排序，以下是线性时间排序==============================<br/>
<em>CountingSort<br/>
计数排序是通过外设一个数组，以所排列的元素的值做为数组的下标来记录所有等于该值的元素的个数，最后根据需求正反输出<br/>
特别适用于元素值之间跨度不大的数组的排序（如果元素值之间跨度不大、但元素值特别大的情况可以通过所有元素减去某统一值的方法来削减空间开销）<br/>
时间复杂度：O(n)<br/>
空间复杂度：O(x)    //x为元素中最大的数<br/>
void CountingSort(int ary[], int size, int max)    //算法导论上的<br/>
{<br/>
    int </em>temp = new int[max];<br/>
    int <em>result = new int[size];<br/>
    memset(temp, 0, max * 4);<br/>
    for(int i = 0; i &lt; size; ++i)<br/>
        ++temp[ary[i]];<br/>
    for(int i = 1; i &lt; max; ++i)<br/>
        temp[i] += temp[i - 1];//将等于i的元素的个数加上等于i-1的元素的个数,此循环结束后，                            //temp[i]存储的就是i在结果中的位置<br/>
    for(int i = size - 1; i &gt;= 0; --i)//一定要降序，否则排序会失去稳定性，此处的稳定性是指：<br/>
    {                //对于相同值的元素，彼此的相对位置是不变的<br/>
                    //即在原始数组中先出现的，在结果中也一定先出现<br/>
                    //这一点对包含在基数排序中的计数排序来说是必须的<br/>
        result[temp[ary[i]] - 1] = ary[i];//temp[ary[i]]-1就是ary[i]在结果中位置的下标<br/>
        --temp[ary[i]];    //如果有相同元素，则让该元素在结果中的位置向前移动一位<br/>
    }            //以免其他相同值的元素都落在同一下标上<br/>
    for(int i = 0; i &lt; size; ++i)        //将结果复制进原数组<br/>
        ary[i] = result[i];<br/>
    delete []temp;<br/>
    delete []result;<br/>
}<br/>
void CountingSort(int ary[], int size, int max)    //自己写的，不稳定<br/>
{<br/>
    int </em>temp = new int[max];<br/>
    memset(temp, 0, max * 4);<br/>
    for(int i = 0; i &lt; size; ++i)<br/>
        ++temp[ary[i]];<br/>
    for(int i = 0, j = 0; i &lt; max; ++i)    //虽然嵌套了，但实际复杂度应该也为O(n)<br/>
        if(temp[i])<br/>
            for(int k = 0; k &lt; temp[i]; ++k)<br/>
                ary[j++] = i;<br/>
    delete []temp;<br/>
}<br/>
int main()<br/>
{<br/>
    int a[10] = {7, 8, 0, 9, 3, 6, 4, 2, 1, 5};<br/>
    CountingSort(a, 10, 10);<br/>
    for(int i = 0; i &lt; 10; ++i)<br/>
        cout&lt;&lt;a[i]&lt;&lt;\' \';<br/>
    return 0;<br/>
}</p>
<hr/>
<p>RadixSort<br/>
基数排序是通过先排序元素的最低有效数字再逐位排序直到最高有效数字来排序的，也就是按照元素每个数位上的数来排序，且顺序是从最低位向最高位；如果元素的位数不同的话，在较短的元素的前面加0来统一位数<br/>
关于此算法，很重要的一点就是按位排序的算法要“稳定”：<br/>
    对于相同值的元素，彼此的相对位置是不变的<br/>
    即在原始数组中先出现的，在结果中也一定先出现<br/>
每位上的数字稳定为0~9，所以计数排序（而且是稳定的）尤其合适作为基数排序中的按位排序<br/>
在一台典型的顺序存取计算机上，有时采用基数排序来对有多个关键字域的记录进行排序，比如日期：年、月、日<br/>
给定n个d位数，每一位可以取k种可能的值，基数排序算法能以O(d(n+k))的时间正确的对这些数排序<br/>
给定n个b位数以及任何r&lt;=b，基数排序能在O((b/r)(n+2^r))时间正确的对这些数排序<br/>
时间复杂度：O(n)<br/>
空间复杂度：O(x)    //x为某一位中最大的数<br/>
void RadixSort(int ary[],int digit,int size,int max)<br/>
{<br/>
    int <em>result=new int[size];<br/>
    int </em>temp=new int[max];<br/>
    int radix=1;<br/>
    int t;<br/>
    for (int i=0;i&lt;digit;++i,radix <em>= 10)    //循环元素的位数次<br/>
    {<br/>
        memset(temp,0,max</em>4);    //每次循环前初始化temp，否则temp的元素值会累加<br/>
        for(int j=0;j&lt;size;++j)<br/>
        {<br/>
            t=ary[j]/radix%10;    //得到各个数位上的数<br/>
            ++temp[t];<br/>
        }<br/>
        for(int j=1;j<max;++j) for(int="" j="size-1;j" temp[j]+="temp[j-1];">=0;--j)<br/>
        {<br/>
            t=ary[j]/radix%10;<br/>
            result[temp[t]-1]=ary[j];<br/>
            --temp[t];<br/>
        }<br/>
        for(int i=0;i&lt;size;++i)        //将结果复制进原数组<br/>
            ary[i]=result[i];<br/>
    }<br/>
    delete []result;<br/>
    delete []temp;<br/>
}<br/>
int main()<br/>
{<br/>
    int a[10]={329,457,657,839,436,720,355,839,220,653};<br/>
    RadixSort(a,3,10,10);<br/>
    for(int i=0;i&lt;10;++i)<br/>
        cout&lt;&lt;a[i]&lt;&lt;\' \';<br/>
    return 0;<br/>
}<br/>
==========================================================================<br/>
BucketSort<br/>
当输入符合均匀分布时，桶排序就能以线性时间运行<br/>
桶排序的思想就是把元素的区间划分为n个大小相同的子区间，称为桶；然后将n个数分布到各个桶中去，因为是均匀分布，所以不会出现很多个元素落在同一桶中的情况；为得到结果，先对各个桶中的元素排序，再按顺序将各个桶中的元素输出即可<br/>
即使输入不符合均匀分布，但只要满足各个桶的尺寸的平方与总的元素数呈线性关系，那么也能以线性时间运行<br/>
时间复杂度：O(n)<br/>
空间复杂度：O(n)<br/>
void BucketSort(int ary[],int size)    //以排序百分制成绩为例<br/>
{<br/>
    vector<int> <em>bucket=new vector<int>[size+1];<br/>
    int index,last;<br/>
    for(int i=0;i<size;++i) bucket[index].push_back(ary[i]);="" index="ary[i]/10;" last="bucket[index].size()-1;" while(last="" {="" 计算应该放入哪个桶="" 计算插入前的最后一个元素的下标="">=0&amp;&amp;bucket[index][last]&gt;ary[i])    //排序<br/>
        {<br/>
            swap(bucket[index][last],bucket[index][last+1]);<br/>
            --last;<br/>
        }<br/>
    }<br/>
    int k=0;<br/>
    for(int i=0;i&lt;size+1;++i)    //按桶顺序将各桶中的元素复制进原数组<br/>
        for(int j=0;j&lt;bucket[i].size();++j)<br/>
            ary[k++]=bucket[i][j];<br/>
    delete []bucket;<br/>
}<br/>
int main()<br/>
{<br/>
    int a[10]={0,45,57,89,100,70,35,39,20,53};<br/>
    BucketSort(a,10);<br/>
    for(int i=0;i&lt;10;++i)<br/>
        cout&lt;&lt;a[i]&lt;&lt;\' \';<br/>
    return 0;<br/>
}<br/>
================================================================================================<br/>
中位数和顺序统计学<br/>
0、在一个由n个元素组成的集合中，第i个顺序统计量是该集合中第i小的元素<br/>
1、中位数是它所在集合的“中点元素”；当n为奇数时，中位数是唯一的，出现在i=(n+1)/2处；当n为偶数时，存在两个中位数，分别出现在i=n/2处和i=n/2+1处<br/>
2、找出集合中的最大和最小元素需要比较多少次？<br/>
    找出集合中的最大元素的比较上界是n-1次，最小元素也是一样<br/>
3、如果要找出最大和最小元素，看起来需要2n-2次；事实上至多3(n/2)次比较就足以同时找到最大和最小元素：<br/>
    成对的处理元素，先将一对元素互相比较，然后把较小的与当前最小元素比较，把较大的与当前最大元素比较，因此每两个元素需要比较3次<br/>
如何设定当前最大和最小值的初始值依赖于n是奇数还是偶数；如果n是奇数，就将最大值和最小值都设为第一个元素的值，然后成对的处理余下的元素；如果n是偶数，就对前两个元素做一次比较，以决定最大值和最小值的初值，然后如同n是奇数的情况一样，成对的处理余下的元素<br/>
4、期望情况为线性时间的选择：<br/>
期望时间复杂度：O(n)<br/>
最坏时间复杂度：O(n</size;++i)></int></em>n)<br/>
int Partition(int ary[],int left,int right)    //快排的划分函数<br/>
{<br/>
    int i=left-1;<br/>
    for(int j=left;j&lt;right;++j)<br/>
        if(ary[j]&lt;=ary[right])<br/>
        {<br/>
            ++i;<br/>
            swap(ary[i],ary[j]);<br/>
        }<br/>
    swap(ary[i+1],ary[right]);<br/>
    return i+1;<br/>
}<br/>
int RandomizedPartition(int ary[],int left,int right)    //快排的随机划分<br/>
{<br/>
    srand((unsigned)time(NULL));<br/>
    int rdm=rand()%(right-left)+left;<br/>
    swap(ary[right],ary[rdm]);<br/>
    return Partition(ary,left,right);<br/>
}<br/>
int RandomizedSelect(int ary[],int left,int right,int i)<br/>
{                        //返回的是第i小的元素<br/>
    if(left==right)<br/>
        return ary[left];<br/>
    int rdm=RandomizedPartition(ary,left,right);    //rdm是划分之后主元的下标<br/>
    int k=rdm-left+1;    //k是主元在当前区间中的第几个<br/>
    if(i==k)    //如果当前主元的位置k等于i，那么k对应的下标r就是所求元素的下标<br/>
        return ary[rdm];<br/>
    else if(i&lt;k)<br/>
        return RandomizedSelect(ary,left,rdm-1,i);<br/>
    else<br/>
        return RandomizedSelect(ary,rdm+1,right,i-k);<br/>
    //为什么i-k ?<br/>
    //因为已经知道有k个元素（即ary[left..rdm]中的所有元素）小于ary[left..right]<br/>
        //中的第i小元素，所以所求元素必是ary[rdm+1..right]中的第i-k小的元素<br/>
}<br/>
int main()<br/>
{<br/>
    int a[10]={0,45,57,89,100,70,35,39,20,53};<br/>
    for(int i=1;i&lt;11;++i)<br/>
    {<br/>
        cout&lt;&lt;\"第\"&lt;&lt;i&lt;&lt;\"小的数为：\";<br/>
        cout&lt;&lt;RandomizedSelect(a,0,9,i)&lt;&lt;endl;<br/>
    }<br/>
    return 0;<br/>
}</int></max;++j)></p>
<hr/>
<p>5、最坏情况为线性时间的选择：<br/>
int SelectPartition(int ary[],int left,int right,int pivot)<br/>
{<br/>
    int i=left-1,j;<br/>
    for(j=left;j&lt;=right;++j)<br/>
        if(ary[j]==pivot)    //找到pivot的下标<br/>
            break;<br/>
    swap(ary[j],ary[right]);<br/>
    for(j=left;j&lt;right;++j)<br/>
        if(ary[j]&lt;=pivot)<br/>
        {<br/>
            ++i;<br/>
            swap(ary[i],ary[j]);<br/>
        }<br/>
    swap(ary[i+1],ary[right]);<br/>
    return i+1;<br/>
}<br/>
void InsertionSort(int ary[],int left,int right)<br/>
{<br/>
    for(int i=left+1;i&lt;=right;++i)<br/>
    {<br/>
        int t=ary[i];<br/>
        int j=i-1;<br/>
        while(j &gt;= left &amp;&amp; ary[j] &gt; t)    //注意：略做修改，是j&gt;=left<br/>
        {<br/>
            ary[j+1] = ary[j];<br/>
            --j;<br/>
        }<br/>
        ary[j+1]=t;<br/>
    }<br/>
}<br/>
int Select(int ary[],int left,int right,int i)<br/>
{                        //返回的是第i小的元素<br/>
    if(right-left&lt;5)<br/>
    {<br/>
        InsertionSort(ary,left,right);<br/>
        return ary[left+i];<br/>
    }<br/>
    int l,r;<br/>
    for(int j=0;j&lt;(right-left+5)/5;++j)<br/>
    {<br/>
        l=left+j<em>5,    //确定分组的left<br/>
        r=(left+j</em>5+4)&gt;right?right:left+j*5+4;    //确定分组的right<br/>
        InsertionSort(ary,l,r);    //排序当前分组<br/>
        swap(ary[left+j],ary[l+(r-l)/2]);    //将各分组的中位数依次交换到前面<br/>
    }<br/>
    l=left;<br/>
    r=left+(right-left)/5;    //定位移动之后的最右边中位数的位置，中位数的区间<br/>
    int pivot=Select(ary,l,r,(r-l)/2);    //中位数的中位数<br/>
    int m=SelectPartition(ary,left,right,pivot);    //用中位数来划分<br/>
    int x=m-left;    //左边m-left个元素，右边right-m-1个元素，中间的是划分元素<br/>
    if(i==x)<br/>
        return ary[m];<br/>
    else if(i&lt;x)<br/>
        return Select(ary,left,m-1,i);<br/>
    else<br/>
        return Select(ary,m+1,right,i-x-1);<br/>
}<br/>
int main()<br/>
{<br/>
    int a[10]={0,45,57,89,100,70,35,39,20,53};<br/>
    for(int i=0;i&lt;10;++i)<br/>
    {<br/>
        cout&lt;&lt;\"第\"&lt;&lt;i&lt;&lt;\"小的数为：\";<br/>
        cout&lt;&lt;Select(a,0,9,i)&lt;<endl; 0;="" <br="" int="" n)="" r[],="" return="" shellsort(int="" void="" {="" }="//希尔排序">    int i;
    int d;
    int j;
    for (d=n/2; d&gt;=1; d=d/2)            //以增量为d进行直接插入排序<br/>
    {<br/>
        for (i=d+1; i<n; <br="" i++)="">        { <br/>            r[0]=r[i];                 //暂存被插入记录
            for (j=i-d; j&gt;0 &amp;&amp; r[0]&lt;r[j]; j=j-d)<br/>
                r[j+d]=r[j];       //记录后移d个位置<br/>
            r[j+d]=r[0];<br/>
         }<br/>
    }<br/>
    for(i=1;i&lt;n;i++)<br/>
        cout&lt;&lt;r[i]&lt;&lt;\" \";<br/>
}<br/>
//冒泡排序<br/>
void BubbleSort(int r[], int n)<br/>
{<br/>
    int temp;<br/>
    int exchange;<br/>
    int bound;<br/>
    exchange=n-1;                       //第一趟起泡排序的范围是r[0]到r[n-1] <br/>
    while (exchange)                    //仅当上一趟排序有记录交换才进行本趟排序<br/>
    {<br/>
        bound=exchange;<br/>
        exchange=0; <br/>
        for (int j=0; j<bound; (r[j]="" if="" j++)="" 一趟起泡排序="">r[j+1])<br/>
            {<br/>
                temp=r[j];<br/>
                r[j]=r[j+1];<br/>
                r[j+1]=temp;<br/>
                exchange=j;                   //记录每一次发生记录交换的位置<br/>
            }<br/>
    }<br/>
    for(int i=0;i&lt;n;i++)<br/>
        cout&lt;&lt;r[i]&lt;&lt;\" \";<br/>
    cout&lt;&lt;\"\n\";<br/>
}<br/>
//快速排序一次划分<br/>
int Partition(int r[], int first, int end)<br/>
{ <br/>
    int i=first;                        //初始化<br/>
    int j=end;<br/>
    int temp;     <br/>
    while (i&lt;j) <br/>
    { <br/>
        while (i&lt;j &amp;&amp; r[i]&lt;= r[j])<br/>
            j--;                        //右侧扫描<br/>
        if (i&lt;j)<br/>
        {<br/>
            temp=r[i];                 //将较小记录交换到前面<br/>
            r[i]=r[j];<br/>
            r[j]=temp;<br/>
            i++;<br/>
        }<br/>
        while (i&lt;j &amp;&amp; r[i]&lt;= r[j])<br/>
            i++;                         //左侧扫描<br/>
        if (i&lt;j)<br/>
        {<br/>
            temp=r[j];<br/>
            r[j]=r[i];<br/>
            r[i]=temp;                //将较大记录交换到后面<br/>
            j--;<br/>
         }<br/>
    }<br/>
    return i;                           //i为轴值记录的最终位置<br/>
}<br/>
//快速排序<br/>
void QuickSort(int r[], int first, int end)<br/>
{<br/>
    if (first&lt;end)<br/>
    {                                   //递归结束<br/>
        int pivot=Partition(r, first, end);  //一次划分<br/>
        QuickSort(r, first, pivot-1);//递归地对左侧子序列进行快速排序<br/>
        QuickSort(r, pivot+1, end);  //递归地对右侧子序列进行快速排序<br/>
    }<br/>
}<br/>
//简单选择排序<br/>
void SelectSort(int r[ ], int n)<br/>
{<br/>
    int i;<br/>
    int j;<br/>
    int index;<br/>
    int temp;<br/>
    for (i=0; i&lt;n-1; i++)                  //对n个记录进行n-1趟简单选择排序<br/>
    { <br/>
        index=i;       <br/>
        for (j=i+1; j&lt;n; j++)            //在无序区中选取最小记录<br/>
            if (r[j]&lt;r[index])<br/>
                index=j;<br/>
        if (index!=i)<br/>
        {<br/>
            temp=r[i];<br/>
            r[i]=r[index];<br/>
            r[index]=temp;<br/>
        }<br/>
    }<br/>
    for(i=0;i&lt;n;i++)<br/>
        cout&lt;&lt;r[i]&lt;&lt;\" \";<br/>
    cout&lt;&lt;\"\n\";<br/>
}<br/>
//筛选法调整堆<br/>
void Sift(int r[], int k, int m)<br/>
{</bound;></n;></endl;></p>
<div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nc">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="nc">int</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>
<span class="nc">int</span><span class="w"> </span><span class="n">temp</span><span class="p">;</span>
<span class="n">i</span><span class="o">=</span><span class="n">k</span><span class="p">;</span>
<span class="n">j</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="w">                            </span><span class="o">//</span><span class="n">置i为要筛的结点</span><span class="err">，</span><span class="n">j为i的左孩子</span>
<span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">m</span><span class="p">)</span><span class="w">                          </span><span class="o">//</span><span class="n">筛选还没有进行到叶子</span>
<span class="err">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="o">&lt;</span><span class="n">m</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">r</span><span class="o">[</span><span class="n">j</span><span class="o">]&lt;</span><span class="n">r</span><span class="o">[</span><span class="n">j+1</span><span class="o">]</span><span class="p">)</span>
<span class="w">        </span><span class="n">j</span><span class="o">++</span><span class="p">;</span><span class="w">                          </span><span class="o">//</span><span class="n">比较i的左右孩子</span><span class="err">，</span><span class="n">j为较大者</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">r</span><span class="o">[</span><span class="n">i</span><span class="o">]&gt;</span><span class="n">r</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="p">)</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w">             </span><span class="o">//</span><span class="n">根结点已经大于左右孩子中的较大者</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">    </span><span class="err">{</span>
<span class="w">        </span><span class="n">temp</span><span class="o">=</span><span class="n">r</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">;</span>
<span class="w">        </span><span class="n">r</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span><span class="n">r</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="p">;</span>
<span class="w">        </span><span class="n">r</span><span class="o">[</span><span class="n">j</span><span class="o">]=</span><span class="n">temp</span><span class="p">;</span><span class="w">                   </span><span class="o">//</span><span class="n">将根结点与结点j交换</span>
<span class="w">        </span><span class="n">i</span><span class="o">=</span><span class="n">j</span><span class="p">;</span>
<span class="w">        </span><span class="n">j</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="w">                     </span><span class="o">//</span><span class="n">被筛结点位于原来结点j的位置</span>
<span class="w">    </span><span class="err">}</span>
<span class="err">}</span>
</code></pre></div></td></tr></table></div>
<p>}<br/>
//堆排序<br/>
void HeapSort(int r[ ], int n)<br/>
{</p>
<div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nc">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="nc">int</span><span class="w"> </span><span class="n">temp</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">--</span><span class="p">)</span><span class="w">                </span><span class="o">//</span><span class="n">初始建堆</span><span class="err">，</span><span class="n">从最后一个非终端结点至根结点</span>
<span class="n">Sift</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w">     </span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">--</span><span class="p">)</span><span class="w">                </span><span class="o">//</span><span class="n">重复执行移走堆顶及重建堆的操作</span>
<span class="err">{</span>
<span class="w">    </span><span class="n">temp</span><span class="o">=</span><span class="n">r</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">;</span>
<span class="w">    </span><span class="n">r</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span><span class="n">r</span><span class="o">[</span><span class="n">0</span><span class="o">]</span><span class="p">;</span>
<span class="w">    </span><span class="n">r</span><span class="o">[</span><span class="n">0</span><span class="o">]=</span><span class="n">temp</span><span class="p">;</span>
<span class="w">    </span><span class="n">Sift</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="err">}</span>
<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">r</span><span class="o">[</span><span class="n">i</span><span class="o">]&lt;&lt;</span><span class="err">\</span><span class="ss">" \"</span><span class="p">;</span>
<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="err">\</span><span class="ss">"\\n\"</span><span class="p">;</span>
</code></pre></div></td></tr></table></div>
<p>}<br/>
//一次归并<br/>
void Merge(int r[], int r1[], int s, int m, int t)<br/>
{<br/>
    int i=s;<br/>
    int j=m+1;<br/>
    int k=s;</p>
<div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">m</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">j</span><span class="o">&lt;=</span><span class="n">t</span><span class="p">)</span>
<span class="err">{</span><span class="w">   </span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">r</span><span class="o">[</span><span class="n">i</span><span class="o">]&lt;=</span><span class="n">r</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="p">)</span>
<span class="w">        </span><span class="n">r1</span><span class="o">[</span><span class="n">k++</span><span class="o">]=</span><span class="n">r</span><span class="o">[</span><span class="n">i++</span><span class="o">]</span><span class="p">;</span><span class="w">            </span><span class="o">//</span><span class="n">取r</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="n">和r</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="n">中较小者放入r1</span><span class="o">[</span><span class="n">k</span><span class="o">]</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">        </span><span class="n">r1</span><span class="o">[</span><span class="n">k++</span><span class="o">]=</span><span class="n">r</span><span class="o">[</span><span class="n">j++</span><span class="o">]</span><span class="p">;</span>
<span class="err">}</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">m</span><span class="p">)</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">m</span><span class="p">)</span><span class="w">                  </span><span class="o">//</span><span class="n">若第一个子序列没处理完</span><span class="err">，</span><span class="n">则进行收尾处理</span><span class="w">         </span>
<span class="w">        </span><span class="n">r1</span><span class="o">[</span><span class="n">k++</span><span class="o">]=</span><span class="n">r</span><span class="o">[</span><span class="n">i++</span><span class="o">]</span><span class="p">;</span>
<span class="k">else</span><span class="w"> </span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">t</span><span class="p">)</span><span class="w">                  </span><span class="o">//</span><span class="n">若第二个子序列没处理完</span><span class="err">，</span><span class="n">则进行收尾处理</span><span class="w">       </span>
<span class="w">        </span><span class="n">r1</span><span class="o">[</span><span class="n">k++</span><span class="o">]=</span><span class="n">r</span><span class="o">[</span><span class="n">j++</span><span class="o">]</span><span class="p">;</span>
</code></pre></div></td></tr></table></div>
<p>}<br/>
//一趟归并<br/>
void MergePass(int r[ ], int r1[ ], int n, int h)<br/>
{<br/>
    int i=0;<br/>
    int k;<br/>
    while (i&lt;=n-2<em>h)                     //待归并记录至少有两个长度为h的子序列<br/>
       {<br/>
        Merge(r, r1, i, i+h-1, i+2</em>h-1);<br/>
        i+=2<em>h;<br/>
    }<br/>
    if (i&lt;n-h)<br/>
        Merge(r, r1, i, i+h-1, n);       //待归并序列中有一个长度小于h<br/>
    else<br/>
        for(k=i; k&lt;=n; k++)            //待归并序列中只剩一个子序列<br/>
            r1[k]=r[k];<br/>
}<br/>
//归并排序的非递归算法<br/>
void MergeSort1(int r[ ], int r1[ ], int n )<br/>
{<br/>
    int h=1;<br/>
    int i;<br/>
    while (h&lt;n)<br/>
    {<br/>
        MergePass(r, r1, n-1, h);           //归并<br/>
        h=2</em>h;<br/>
        MergePass(r1, r, n-1, h);<br/>
        h=2*h;<br/>
    }<br/>
    for(i=0;i&lt;n;i++)<br/>
        cout&lt;&lt;r[i]&lt;&lt;\" \";<br/>
    cout&lt;&lt;\"\n\";<br/>
}<br/>
//归并排序的递归算法<br/>
void MergeSort2(int r[], int r1[], int r2[],int s, int t)<br/>
{</p>
<div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nc">int</span><span class="w"> </span><span class="n">m</span><span class="p">;</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="o">==</span><span class="n">t</span><span class="p">)</span>
<span class="err">{</span>
<span class="w">    </span><span class="n">r1</span><span class="o">[</span><span class="n">s</span><span class="o">]=</span><span class="n">r</span><span class="o">[</span><span class="n">s</span><span class="o">]</span><span class="p">;</span>
<span class="err">}</span>
<span class="k">else</span>
<span class="err">{</span>
<span class="w">        </span><span class="n">m</span><span class="o">=</span><span class="p">(</span><span class="n">s</span><span class="o">+</span><span class="n">t</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
<span class="w">        </span><span class="n">MergeSort2</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">r2</span><span class="p">,</span><span class="w"> </span><span class="n">r1</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">);</span><span class="w">        </span><span class="o">//</span><span class="n">归并排序前半个子序列</span><span class="w">       </span>
<span class="w">        </span><span class="n">MergeSort2</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">r2</span><span class="p">,</span><span class="w"> </span><span class="n">r1</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="p">);</span><span class="w">      </span><span class="o">//</span><span class="n">归并排序后半个子序列</span>
<span class="w">        </span><span class="k">Merge</span><span class="p">(</span><span class="n">r2</span><span class="p">,</span><span class="w"> </span><span class="n">r1</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="p">);</span><span class="w">             </span><span class="o">//</span><span class="n">将两个已排序的子序列归并</span><span class="w">         </span>
<span class="err">}</span>
</code></pre></div></td></tr></table></div>
<p>}</p>
<hr/>
<blockquote>
<p>以上来自 QQ群: <strong>C++/Python/Qt技术交流</strong> 大佬 <code>Icy</code></p>
</blockquote>
                </div>
            </article>
        </main>
    </div>

    <footer>
        <p>© 2025 我的博客 · 基于Markdown生成</p>
    </footer>
</body>
</html>